# 项目技术使用介绍

## 爬虫
- **核心任务**: 爬取 UNSW Handbook 资料，分为课程资料和毕业要求两部分。
- **课程资料爬取**:
    - **步骤一 (获取课程代码)**: 针对大专业（如 COMP），直接爬取静态 HTML 页面，解析并获取该专业下的全部课程代码。
    - **步骤二 (获取详细信息)**: 对于无法通过静态 HTML 获取的动态加载内容，通过分析 DOM 更新前调用的 API 接口，直接请求该 API 以获取完整的课程详细资料。
- **毕业要求爬取**:
    - **步骤一 (获取专业方向)**: 针对特定专业方向（如 COMPIH），由于数据是动态加载且无明显 API 调用，采用模拟浏览器控制台执行 JavaScript 的方式，直接调用页面内置的 `__NEXT_DATA__` 对象来获取前端渲染所需的数据。
    - **步骤二 (数据清洗)**: 对获取到的 JSON 数据进行解析和清洗，移除如 `id`, `key` 等无用字段，保留核心毕业要求信息。
- **反爬虫策略**:
    - **并发控制**: 采用并发请求以提高效率，并设置随机延迟和重试机制，模拟人类行为。
    - **请求头伪装**: 使用随机的 `User-Agent` 和 `Referer` 来伪装请求来源，防止因访问频率过高或请求头单一而被服务器封禁。

---


## 🚀 Django 后端 (Backend)
- **流式响应 (Streaming Response)**: 为对接大语言模型的生成式任务，后端采用 `StreamingHttpResponse` 实现流式输出。该设计能够将模型生成的文本以数据流的形式逐块发送至前端，实现打字机效果，极大降低了用户的“首词等待时间” (Time to First Token)，优化了长时间生成任务的交互体验。
- **数据库缓存 (Database Caching)**: 针对课程信息、毕业要求等不频繁变更但查询频率高的数据，集成了数据库缓存策略（如使用 Redis）。当首次查询后，结果会被缓存，后续相同请求将直接从缓存中高速读取，显著降低数据库负载，提升 API 响应速度。

---

## 🖥️ 前端 (Frontend)
- **技术栈**: 采用 **React** 框架进行开发，构建现代化、响应式的单页面应用 (SPA)。
- **核心设计**:
    - **组件化架构**: 将 UI 拆分为独立、可复用的组件，提高了代码的可维护性和开发效率。
    - **状态管理**: 通过高效的状态管理库（如 Redux or Context API）来同步前端界面与后端数据，确保用户交互的流畅性和数据的一致性。
    - **用户体验**: 专注于打造一个直观、易用的交互界面，让学生可以轻松地进行课程查询、规划和获取智能建议。

---

## 🌐 Chrome 插件 (Chrome Extension)
- **定位**: 作为 “UNSW Course Advisor” 的轻量级入口，无缝集成于用户的浏览器环境中，提供即时、智能的课程辅助。
- **核心功能**:
    - **账户数据集成**: 支持用户登录 UNSW 学生账号，安全地获取个人已修课程、当前在读课程等官方数据。
    - **个性化课程过滤**: 基于获取的官方数据，插件能够自动排除用户已完成或不符合前置要求的课程，有效过滤干扰信息，使推荐结果更具针对性。
- **规划中功能 (In Development)**:
    - **上下文感知与智能调用**: 插件将具备上下文感知能力，例如在浏览 Handbook 页面时自动激活。通过设置智能阈值，仅在识别到用户有相关意图时才调用后端 RAG 服务，避免不必要的资源消耗。
    - **携带记忆的自动选课**: 计划实现一个高级功能，插件将携带用户的长期偏好记忆（例如对 AI、系统编程等领域的兴趣）和短期会话上下文，在选课阶段提供高度个性化和自动化的课程篮子填充建议。
## 🔍 RAG检索增强生成系统 (Retrieval-Augmented Generation)

### 数据管道架构
- **双向量库并行设计**:
    - **课程知识库**: 存储从 Handbook 爬取的详细课程信息，包括课程代码、描述、学分、前置要求等。
    - **毕业要求库**: 存储各专业方向的毕业学分要求、课程组合规则等结构化数据。
- **并行检索机制**: 当用户发起查询时，系统会同时在两个向量库中进行检索，确保综合课程细节和毕业规则，返回最全面的信息。

### 嵌入与检索优化

---

## 🧠 LangGraph 智能代理系统

### 多模型路由架构
- **智能模型调度**:
    - **路由模型 (Router)**: 使用轻量级的 `Qwen-2.5-1.5B-flash` 模型进行快速的意图识别和任务路由决策。
    - **执行模型 (Worker)**: 采用 `Qwen-2.5-7B-plus` 模型处理大部分复杂的推理和生成任务。
    - **增强模型 (Expert)**: 备用 `Qwen-2.5-14B-max` 模型，用于应对少数极高难度的查询，作为专家模型。
- **性能优化策略**:
    - **首词延迟优化 (Time to First Token)**: 通过 flash 模型快速生成响应的开头，极大提升用户感知的响应速度。
    - **负载均衡**: 根据查询的复杂度动态分配到合适的模型，避免资源浪费，实现成本和性能的平衡。
    - **流式输出 (Streaming)**: 实现逐词生成并输出的效果，减少用户的等待焦虑。

### RAG 调用智能决策
- **动态阈值机制**:
    - **置信度评估**: 系统首先对用户查询进行意图分析，计算调用 RAG 系统的必要性得分。
    - **阈值判断**: 设置 `0.7` 的置信度阈值，只有当得分高于此阈值时，才触发 RAG 检索流程。
    - **降级处理 (Fallback)**: 对于低置信度的查询（如闲聊、通用知识提问），直接由大模型基于其内部知识回答，节省不必要的检索开销。
- **结果验证流程**:
    1.  **意图分析**: 使用 flash 模型分析用户查询的真实意图。
    2.  **检索调用**: 基于分析结果决定是否调用 RAG 系统。
    3.  **相关性验证**: 对 RAG 返回的文档进行质量评估和相关性验证。
    4.  **答案生成**: 结合高质量的检索结果和模型自身知识，生成最终回答。

### 自评判代理设计 (Self-Correction Agent)
- **多阶段验证体系**:
    - **检索质量评估**: Agent 自行对 RAG 返回文档的相关性进行评分。
    - **答案一致性检查**: 确保生成的答案与引用的检索信息不存在矛盾。
    - **实用性验证**: 评估生成的课程建议等是否具有可行性和实际应用价值。
- **错误处理机制**:
    - **超时降级**: 当 RAG 检索超时，系统自动切换到模型直接回答模式。
    - **空结果处理**: 当检索结果为空时，使用预定义的模板进行友好响应，而非返回错误或无关信息。
    - **质量回溯**: 记录每次检索和生成的质量指标，用于系统的持续迭代和优化。

### 记忆管理策略
- **上下文记忆**:
    - **会话记忆 (Short-term)**: 在当前对话中维护上下文信息，理解多轮对话。
    - **长期记忆 (Long-term)**: 存储用户的核心偏好（如感兴趣的专业方向）和关键历史交互模式。
- **记忆优化**:
    - **记忆压缩**: 对长期记忆进行摘要和压缩处理，减少存储和检索成本。
    - **重要性排序**: 基于记忆的使用频率和相关性进行排序，优先检索最重要的信息。
    - **过期清理**: 定期清理过时或不再有用的记忆信息，保持记忆库的高效和相关性。

---

### 许可

```
┌────────────────────────────────────────────────────────┐
│                    用户流程                             │
├────────────────────────────────────────────────────────┤
│                                                        │
│  1️⃣ 网页生成加密文件（免费）                             │
│     ↓                                                  │
│     加密数据 + 文件 ID                                  │
│                                                        │
│  2️⃣ 用户想用插件解密 → 需要购买许可证                    │
│     ↓                                                  │
│     支付 → 获得许可证密钥（License Key）                 │
│                                                        │
│  3️⃣ 插件激活                                           │
│     ↓                                                  │
│     输入 License Key → 向服务器验证                     │
│     ↓                                                  │
│     服务器返回解密密钥（动态生成，绑定用户）              │
│                                                        │
│  4️⃣ 解密并使用数据                                      │
│                                                        │
└────────────────────────────────────────────────────────┘
```
```
SERVER_MASTER_KEY 
         ↓
    派生算法（PBKDF2 + file_id）
         ↓
    FILE_ENCRYPTION_KEY (每个文件不同)
         ↓
    加密用户数据
         
         
USER_DECRYPT_KEY (购买许可证后获得)
         ↓
    FILE_ENCRYPTION_KEY = derive(USER_DECRYPT_KEY + file_id)
         ↓
    解密用户数据
```
---
### 用户体验流程
#### 首次使用
- 1. 用户在网页生成加密文件（免费）
- 2. 下载插件（免费下载，但功能受限）
- 3. 插件提示："该文件需要许可证才能解密"
- 4. 点击"购买许可证" → 跳转支付页面
- 5. 支付后收到 License Key
- 6. 在插件中输入 License Key 激活
- 7. 成功解密并使用数据
#### 后续使用
- 1. 插件自动使用已保存的 decrypt_key
- 2. 后台静默验证许可证状态
- 3. 如许可证即将过期，提示续费